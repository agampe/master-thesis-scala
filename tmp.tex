\subsubsection{Statische versus Dynamsich typisierte Sprachen}
\begin{itemize}
  \item Typing $=_{df}$ \textit{A type system is a tractable syntactic method for preserving the absence of certain
program behaviors by classifying phrases according to the kinds of values they
compute.}

  \item ein Typsystem erlaubt es dem System zu sagen, was alles nicht
  stattfinden soll
  \item ein Typsystem kann verschiedene Fehler abfangen: \textit{like unsupported
operations on particular data structures, attempting to combine data in an undefined
way (e.g., trying to add an integer to a string), breaking abstractions, etc.
}
  \item in \itbf{statischer Typisierung} ist die Variable für seine gesamte Lebenszeit an einen Typ gebunden \und kann diesen nicht ändern
  \item in \itbf{dynamischer Typisierung} ist der Typ zum Wert \und 
  nicht zur Variable gebunden $\Rightarrow$ \textit{duck typung}; es wird
  deswegen von dynamik gesprochen, da der Typ einer Variable erst dann
  ausgewertet wird, wenn es zur Laufzeit verwendet wird
  \item Scala ist eine statisch typisierte Sprache
\end{itemize}



\subsection{Dienst-orientiertes Komponenten-Modell}

\begin{itemize}
  \item Scalas Abstraktion kann als Basis für Dienst-orientiertes 
  Komponenten-Model gesehen werden
  \item Software-Komponenten sind Berechnungseinheiten, die eine wohlgeformte
  Menge von Diensten definieren
  \item in Scala gehören Software-Komponenten zu Klassen \und \textit{traits}
  \item konkrete \textit{Members} einer Klasse \oder \textit{traits} stellen
  die angebotenen Dienste dar, während \textit{derefered Members} als
  benötigte Dienste angesehen werden können
  \item die Komposition von Komponenten basiert auf \textit{mixins}, welche
  es Proggern erlauben, größere Komponenten aus kleineren zu bauen
  \item größte Vorteil gegenüber traditionelle black-box Komponenten ist,
  dass die Komponenten erweiterbare Entitäten sind $\Rightarrow$ wegen
  \textit{subclassing} \und \textit{overriding}
\end{itemize}

